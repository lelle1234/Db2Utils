#!/usr/bin/python3

import os
import os.path
import sys
import getopt
import ibm_db
import ibm_db_dbi

dbname = None
username = None
password = None
table = None
schema = None
filename = None
host = "localhost"

try:
    opts, args = getopt.getopt(sys.argv[1:], "d:s:t:u:p:f:h:")
except getopt.GetoptError:
    sys.exit(-1)
for o, a in opts:
    if (o == "-d"):
        dbname = a
    if (o == "-s"):
        schema = a.upper()
    if (o == "-t"):
        table = a.upper()
    if (o == "-u"):
        username = a
    if (o == "-p"):
        password = a
    if (o == "-f"):
        filename = a
    if (o == "-h"):
        host = a

if filename == None:
    fh = sys.stdout
else:
    fh = open(filename, "w")


try:
    s = dbname + username + password + table + schema
except:
    print ("Usage: ./pretty_print_table.py -d <db> -u <user> -p <pwd> -t <table> -s <schema> [-h host -f <file>]")
    sys.exit(1)

def myprint(s, f):
    print(s, file=f)

ibm_db_conn = ibm_db.connect("DATABASE=%s;HOSTNAME=%s;PORT=50000;PROTOCOL=TCPIP;UID=%s; PWD=%s" % (dbname, host, username, password),"","")
conn = ibm_db_dbi.Connection(ibm_db_conn)

c1 = conn.cursor()
c2 = conn.cursor()

# check if table exists
c1.execute("select type from syscat.tables where (tabschema, tabname) = (?, ?)", (schema, table))
n = c1.fetchone()
if not n:
    print ("Table %s.%s does not exist" % (schema, table))
    sys.exit(1)

type = n[0] #.encode('iso-8859-1')
if type != "T":
    print ("Utility only supports tables, %s.%s is type %s" % (schema, table, type))
    sys.exit(1)

c1.execute('''
    select rtrim(c.colname) colname, rtrim(c.typename) typename
	, c.length / case coalesce(c.typestringunits,'') when 'CODEUNITS32' then 4 else 1 end as length
        , c.scale, c.nulls, case when c.codepage = '0' and c.typename like '%CHAR%'
                                 then 'FOR BIT DATA' else '' end as bit_data
        ,  c.identity, c.generated, c.text
        ,  rtrim(t.tbspace), rtrim(t.index_tbspace), rtrim(t.long_tbspace), t.append_mode
        , rtrim(c.default)
    from syscat.columns c
    join syscat.tables t
        on (t.tabschema, t.tabname) = (c.tabschema, c.tabname)
    where (c.tabschema, c.tabname) = (?,?)
    order by c.colno''', (schema, table))

myprint('', fh)
myprint('CREATE TABLE %s.%s' % (schema, table), fh)

coldecls = []
colnames = []
for row in c1.fetchall():
    colname = row[0]
    typename = row[1]
    length = row[2]
    scale = row[3]
    nulls = ''
    if (row[4] == 'N'):
        nulls = ' NOT NULL'
    bit_data = row[5]
    identity = row[6]
    generated = row[7]
    text = row[8]
    tbspace = row[9]
    inspace = row[10]
    lnspace = row[11]
    append = row[12]
    default = row[13]

    colnames.append(colname)

    if default != None:
        default = "DEFAULT %s" % default
    else:
        default = ""

    gendecl = ''
    if generated == 'D':
        gendecl += "\n\tGENERATED BY DEFAULT "

    elif generated == 'A':
        gendecl += "\n\tGENERATED ALWAYS "

    if identity == 'Y':
        # FIXME: start and increment values
        gendecl += "AS IDENTITY (START WITH 1, INCREMENT BY 1)"

    elif text != None:
        gendecl += text

    typedecl = ''
    if (typename == 'CHARACTER'):
        typedecl = 'CHAR(%s) %s %s %s %s' % (length, bit_data, default, nulls, gendecl)
        coldecls.append('%s %s' % (colname, typedecl))
        continue
    if (typename == 'VARCHAR'):
        typedecl = 'VARCHAR(%s) %s %s %s %s' % (length, bit_data, default, nulls, gendecl)
        coldecls.append('%s %s' % (colname, typedecl))
        continue
    if (typename == 'DECIMAL'):
        typedecl = 'DECIMAL(%s,%s) %s %s %s' % (length, scale, default, nulls, gendecl)
        coldecls.append('%s %s' % (colname, typedecl))
        continue

    typedecl = '%s %s %s %s' % (typename, default, nulls, gendecl)
    coldecls.append('%s %s' % (colname, typedecl))

for c in coldecls:
    if c == coldecls[0]:
        myprint("( " + c, fh)
    else:
        myprint(", " + c, fh)

tblspaces = ') IN %s ' % (tbspace)
if inspace != None:
    tblspaces += 'INDEX IN %s ' % (inspace)
if lnspace != None:
    tblspaces += 'LONG IN %s ' % (lnspace)
tblspaces += "\nCOMPRESS YES ADAPTIVE"
tblspaces += "\nORGANIZE BY ROW " 
tblspaces += '@'

myprint(tblspaces, fh)
print()

if append == "Y":
    myprint("ALTER TABLE %s.%s APPEND ON @" % (schema, table), fh)

# indexes

c1.execute("""
    select rtrim(i.indschema), rtrim(i.indname), i.uniquerule, i.indextype, i.reverse_scans,
           i.pagesplit, i.collectstatistcs, i.user_defined, i.compression
    from syscat.indexes i
    where (tabschema, tabname) = (?, ?)
    order by iid""", (schema, table))

for row in c1.fetchall():
    indschema = row[0]
    indname = row[1]
    uniquerule = row[2]
    indextype = row[3]
    reverse_scans = row[4]
    pagesplit = row[5]
    collectstatistics = row[6]
    user_defined = row[7]
    compression = row[8]

    if user_defined == 0:
        # generated indexes, defined by Db2
        continue

    if uniquerule in ('P','U'):
        uniq = " UNIQUE "
    else:
        uniq = ""

    myprint("", fh)
    myprint("CREATE %s INDEX %s.%s ON %s.%s" % (uniq, indschema, indname, schema, table), fh)

    cols = "\t("
    include = "("
    c2.execute("""select ic.colname, ic.colorder
                  from syscat.indexcoluse ic
                  where (indschema, indname) = (?, ?)
                  order by ic.colseq""", (indschema, indname))
    for subrow in c2.fetchall():
        colname = subrow[0]
        colorder = subrow[1]
        if colorder == "I":
            include += colname + ", "
        elif colorder == "A":
            cols += colname + ", "
        else:
            cols += colname + " DESC, "
   
    cols = cols[:-2] # remove last "," 
    cols += ")"
    myprint(cols, fh)

    include = include[:-2] 
    if include != "":
        myprint("INCLUDE " + include + ")", fh)
    
    if compression == "Y":
        myprint("COMPRESS YES ", fh)

    if indextype == "CLUS":
        myprint("CLUSTER", fh)

    if reverse_scans == "Y":
        myprint("ALLOW REVERSE SCANS", fh)

    if collectstatistics == "D":
        myprint("COLLECT DETAILED STATISTICS @", fh)
    elif collectstatistics == "S":
        myprint("COLLECT SAMPLED DETAILED STATISTICS @", fh)
    elif collectstatistics == "Y":
        myprint("COLLECT STATISTICS @", fh)
    else:
        myprint(" @", fh)

# constraints

c1.execute("""select constname, ownertype, type, enforced, enablequeryopt, remarks
              from syscat.tabconst
              where (tabschema, tabname) = (?, ?)
              order by case type when 'P' then 1
                                 when 'U' then 2
                                 when 'F' then 3
                                 when 'K' then 4
                                 else 5
                       end""", (schema, table))
for row in c1.fetchall():
    constname = row[0]
    ownertype = row[1]
    type = row[2]
    enforced = row[3]
    enablequeryopt = row[4]
    remarks = row[5]

    if type in ('P','U'):
        cols = ""
        c2.execute("""select colname 
                      from syscat.keycoluse k 
                      where (tabschema, tabname, constname) = (?, ?, ?)
                      order by colseq""", (schema, table, constname))
        for subrow in c2.fetchall():
            col = subrow[0]
            cols += col + ", "
        cols = cols[:-2] # remove last ","
        if type == 'P':
            stmt = "\nALTER TABLE %s.%s ADD CONSTRAINT %s\n\tPRIMARY KEY (%s) @" % (schema, table, constname, cols)
        else:
            stmt = "\nALTER TABLE %s.%s ADD CONSTRAINT %s\n\tUNIQUE (%s) @" % (schema, table, constname, cols)
        myprint(stmt, fh)

    elif type == 'F':
        cols = ""
        refcols = ""
        c2.execute("""select rtrim(r.refkeyname), rtrim(r.reftabschema), rtrim(r.reftabname)
                           , r.deleterule, r.updaterule, rtrim(k1.colname), rtrim(k2.colname)
                      from syscat.references r
                      join syscat.keycoluse k1 
                        on (r.tabschema, r.tabname, r.constname)
                         = (k1.tabschema, k1.tabname, k1.constname)
                      join syscat.keycoluse k2 
                        on (r.reftabschema, r.reftabname, r.refkeyname)
                         = (k2.tabschema, k2.tabname, k2.constname)
                        and k1.colseq = k2.colseq
                      where (r.tabschema, r.tabname, r.constname) = (?, ?, ?)
                      order by k1.colseq""", (schema, table, constname))
        for subrow in c2.fetchall():
            refkeyname = subrow[0]
            reftabschema = subrow[1]
            reftabname = subrow[2]
            deleterule = subrow[3]
            updaterule = subrow[4]
            col = subrow[5]
            refcol = subrow[6]
            cols += col + ","
            refcols += refcol + ","

        if deleterule == "A":
            delete = "NO ACTION"
        elif deleterule == "C":
            delete = "CASCADE"
        elif deleterule == "N":
            delete = "SET NULL"
        else:
            delete = "RESTRICT"

        if updaterule == "A":
            update = "NO ACTION"
        else:
            update = "RESTRICT"

        cols = cols[:-1] # remove last ","
        refcols = refcols[:-1] # remove last ","

        stmt = "\nALTER TABLE %s.%s ADD CONSTRAINT %s"
        stmt += "\n\tFOREIGN KEY (%s)"
        stmt += "\n\tREFERENCES %s.%s (%s)"
        stmt += "\n\t\tON DELETE %s"
        stmt += "\n\t\tON UPDATE %s" 

        if enforced == "N":
            stmt += "\nNOT ENFORCED"
        elif enforced == "Y":
            stmt += "\nENFORCED"
        if enablequeryopt == "N":
            stmt += "\nDISABLE QUERY OPTIMIZATION"
        elif enablequeryopt == "Y":
            stmt += "\nENABLE QUERY OPTIMIZATION"

        stmt += " @"
        myprint(stmt % (schema, table, constname, cols, reftabschema, reftabname, refcols, delete, update), fh)

    else: # checks
        c2.execute("select rtrim(c.type), rtrim(c.text), t.enforced, t.enablequeryopt from syscat.checks c join syscat.tabconst t using (constname, tabschema, tabname) where (c.tabschema, c.tabname, c.constname) = (?,?,?)", (schema, table, constname))
        (typex, text, enforced, enablequeryopt) = c2.fetchone()
        if typex != "C":
            # System-generated check constraint for a GENERATED ALWAYS column
            continue

        stmt = "\nALTER TABLE %s.%s ADD CONSTRAINT %s"
        stmt += "\n\tCHECK ( %s )" 
        if enforced == "N":
            stmt += "\nNOT ENFORCED"
        elif enforced == "Y":
            stmt += "\nENFORCED"
        if enablequeryopt == "N":
            stmt += "\nDISABLE QUERY OPTIMIZATION"
        elif enablequeryopt == "Y":
            stmt += "\nENABLE QUERY OPTIMIZATION"

        myprint(stmt % (schema, table, constname, text), fh)

    if remarks != None:
        comment = "\nCOMMENT ON CONSTRAINT %s.%s.%s IS '%s' @" % (schema, table, constname, remarks)
        myprint(comment, fh)


c1.execute("select rtrim(remarks) from syscat.tables where (tabschema, tabname) = (?, ?)", (schema, table))
for row in c1.fetchall():
    comment = row[0]
    if comment != None:
        myprint("\nCOMMENT ON TABLE %s.%s IS '%s' @" % (schema, table, comment), fh)

myprint("\n", fh)
c1.execute("""select rtrim(colname), rtrim(remarks) 
from syscat.columns 
where (tabschema, tabname) = (?,?)
order by colno""", (schema, table))
for row in c1.fetchall():
    col = row[0]
    comment = row[1]
    if comment != None:
        myprint("COMMENT ON COLUMN %s.%s.%s IS '%s' @" % (schema, table, col, comment), fh)

myprint("\n", fh)
